// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: tokens.sql

package models

import (
	"context"

	"github.com/google/uuid"
)

const createTokens = `-- name: CreateTokens :one
INSERT INTO auth.tokens (id, access_token, refresh_token, session, valid)
VALUES ($1, $2, $3, $4, $5) RETURNING id, refresh_token, session, access_token, valid
`

type CreateTokensParams struct {
	ID           uuid.UUID `json:"id"`
	AccessToken  string    `json:"access_token"`
	RefreshToken string    `json:"refresh_token"`
	Session      uuid.UUID `json:"session"`
	Valid        bool      `json:"valid"`
}

func (q *Queries) CreateTokens(ctx context.Context, arg CreateTokensParams) (AuthToken, error) {
	row := q.db.QueryRowContext(ctx, createTokens,
		arg.ID,
		arg.AccessToken,
		arg.RefreshToken,
		arg.Session,
		arg.Valid,
	)
	var i AuthToken
	err := row.Scan(
		&i.ID,
		&i.RefreshToken,
		&i.Session,
		&i.AccessToken,
		&i.Valid,
	)
	return i, err
}

const getAuthByTokens = `-- name: GetAuthByTokens :one
SELECT id, refresh_token, session, access_token, valid FROM auth.tokens
WHERE refresh_token = $1 AND access_token = $2
`

type GetAuthByTokensParams struct {
	RefreshToken string `json:"refresh_token"`
	AccessToken  string `json:"access_token"`
}

func (q *Queries) GetAuthByTokens(ctx context.Context, arg GetAuthByTokensParams) (AuthToken, error) {
	row := q.db.QueryRowContext(ctx, getAuthByTokens, arg.RefreshToken, arg.AccessToken)
	var i AuthToken
	err := row.Scan(
		&i.ID,
		&i.RefreshToken,
		&i.Session,
		&i.AccessToken,
		&i.Valid,
	)
	return i, err
}

const invalidateToken = `-- name: InvalidateToken :one
UPDATE auth.tokens
SET valid = false
WHERE refresh_token = $1 AND access_token = $2
RETURNING id, refresh_token, session, access_token, valid
`

type InvalidateTokenParams struct {
	RefreshToken string `json:"refresh_token"`
	AccessToken  string `json:"access_token"`
}

func (q *Queries) InvalidateToken(ctx context.Context, arg InvalidateTokenParams) (AuthToken, error) {
	row := q.db.QueryRowContext(ctx, invalidateToken, arg.RefreshToken, arg.AccessToken)
	var i AuthToken
	err := row.Scan(
		&i.ID,
		&i.RefreshToken,
		&i.Session,
		&i.AccessToken,
		&i.Valid,
	)
	return i, err
}

const invalidateTokenFamily = `-- name: InvalidateTokenFamily :exec
UPDATE auth.tokens
SET valid = FALSE
WHERE session IN (
  SELECT session FROM auth.tokens token
  WHERE token.access_token = $1 AND token.refresh_token = $2
) AND valid = TRUE
`

type InvalidateTokenFamilyParams struct {
	AccessToken  string `json:"access_token"`
	RefreshToken string `json:"refresh_token"`
}

// TODO: Change invalidation to setting all to invalid, then when user try to refresh the token, if his current one is invalidated, then someone has used old tokens to request new token
func (q *Queries) InvalidateTokenFamily(ctx context.Context, arg InvalidateTokenFamilyParams) error {
	_, err := q.db.ExecContext(ctx, invalidateTokenFamily, arg.AccessToken, arg.RefreshToken)
	return err
}

const logoutTokens = `-- name: LogoutTokens :exec
DELETE FROM auth.tokens
WHERE session IN 
( 
  SELECT session FROM auth.tokens tokens
  WHERE tokens.access_token = $1 AND tokens.refresh_token = $2
)
`

type LogoutTokensParams struct {
	AccessToken  string `json:"access_token"`
	RefreshToken string `json:"refresh_token"`
}

func (q *Queries) LogoutTokens(ctx context.Context, arg LogoutTokensParams) error {
	_, err := q.db.ExecContext(ctx, logoutTokens, arg.AccessToken, arg.RefreshToken)
	return err
}
